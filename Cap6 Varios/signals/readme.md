## signal_example

```ps
gcc -o signal_example signal_example.c

./signal_example
```

```ps
ps a | grep signal_example

1480 pts/0    R+     0:52 ./signal_example
541 pts/1    S+     0:00 grep --color=auto signal_example
```

To list all the signals available:

```ps
kill -l

 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

To send a signal to a given process:

```ps
kill -a bbbbb
```

- a. Signal number
- bbbbb. process id

Por ejemplo:

```s
kill -20 1480
```

En el código indicamos que queremos procesar una señal como sigue:

```c
 signal(SIGQUIT, signal_handler);
 ```

 El handler, `signal_handler`, se ejecutara cada vez que el proceso reciba la señal `SIGQUIT` del SSOO. Una vez el handler termine de ejecutarse, el proceso retomará la ejecución donde la había dejado:

 ```c
 void signal_handler(int signal)
{
    printf("Caught signal %d\t", signal);
    if (signal == SIGTSTP)
        printf("SIGTSTP (Ctrl-Z)");
    else if (signal == SIGQUIT)
        printf("SIGQUIT (Ctrl-\\)");
    else if (signal == SIGUSR1)
        printf("SIGUSR1");
    else if (signal == SIGUSR2)
        printf("SIGUSR2");
    printf("\n");
}
 ```

## tinywebd

Se trata de una extensión del programa `tinyweb.c`. Lo que haremos es convertir el proceso en un demonio, con el que nos comunicaremos usando señales.

Para convertir un proceso en demonio usamos la función `int daemon(int nochdir, int noclose);`. A partir de esta linea el proceso el "código" se desvincula del proceso principal en un demonio. EL proceso principal termina.

```c
    if (daemon(1, 0) == -1) // Fork to a background daemon process.
        fatal("forking to daemon process");

    //Procesamos estas dos señales, y usamos el mismo handler para las dos    
    signal(SIGTERM, handle_shutdown); // Call handle_shutdown when killed.
    signal(SIGINT, handle_shutdown);  // Call handle_shutdown when interrupted.
    
    timestamp(logfd);
    write(logfd, "Starting up.\n", 15);
```

```ps
gcc -g tinywebd.c
```

Si depuramos el proceso de la forma habitual:

```ps
sudo gdb -q ./a.out
```

No conseguiremos que se detenga en un breakpoint después de que se haya creado el demonio. Para poder hacerlo, tendremos que usar la opción `follow-fork-mode child`:

```ps
(gdb) set follow-fork-mode child
```

Otra alternativa para depurar el demonio es attachar el depurador a una instancia que este en ejecución.

Podemos ver la instancia en ejecución:

```ps
reader@hacking:~/booksrc $ ps aux | grep tinywebd

root 25830 0.0 0.0 1636 356 ? Ss 20:10 0:00 ./tinywebd
reader 25837 0.0 0.0 2880 748 pts/1 R+ 20:10 0:00 grep tinywebd
```

Para depurar:

```ps
reader@hacking:~/booksrc $ sudo gdb -q—pid=25830 --symbols=./a.out
```