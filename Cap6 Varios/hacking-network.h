//Envia un mensaje
int send_string(int sockfd, unsigned char *buffer)
{
    int sent_bytes, bytes_to_send;
    bytes_to_send = strlen(buffer);
    //Mientras queden caracteres por enviar
    while (bytes_to_send > 0)
    {
        //Envia caracteres
        sent_bytes = send(sockfd, buffer, bytes_to_send, 0);
        if (sent_bytes == -1)
            return 0; // Return 0 on send error.
        
        bytes_to_send -= sent_bytes;
        //Cambia el puntero de sitio, para que apunte siempre al primer caracter no enviado aún.
        buffer += sent_bytes;
    }
    return 1; // Return 1 on success.
}

/* Recibe un mensaje
* This function accepts a socket FD and a ptr to a destination
* buffer. It will receive from the socket until the EOL byte
* sequence in seen. The EOL bytes are read from the socket, but
* the destination buffer is terminated before these bytes.
* Returns the size of the read line (without EOL bytes).
*/
int recv_line(int sockfd, unsigned char *dest_buffer)
{
    //Secuencia de terminación. Estos caracteres determinan el final de un mensaje
    #define EOL "\r\n" // End-of-line byte sequence
    #define EOL_SIZE 2

    unsigned char *ptr;
    int eol_matched = 0;

    ptr = dest_buffer;

    while (recv(sockfd, ptr, 1, 0) == 1) // Recibe un byte cada vez 
    { 
        //Comprueba si los bytes que recibimos siguen la secuencia que define la terminación de un mensaje
        if (*ptr == EOL[eol_matched])
        { // Does this byte match terminator?
            eol_matched++;
            if (eol_matched == EOL_SIZE)
            {                                 
                // Hemos recibido la secuencia que determina el fin de un mensaje. Quitamos de la información recibida la secuencia de terminación
                *(ptr + 1 - EOL_SIZE) = '\0'; // terminate the string.
                return strlen(dest_buffer);   // Return bytes received
            }
        }
        else
        {
            eol_matched = 0;
        }
        ptr++; // Increment the pointer to the next byter.
    }
    return 0; // Didn't find the end-of-line characters.
}

#define ETHER_ADDR_LEN 6
#define ETHER_HDR_LEN 14
struct ether_hdr
{
    unsigned char ether_dest_addr[ETHER_ADDR_LEN]; // Destination MAC address
    unsigned char ether_src_addr[ETHER_ADDR_LEN];  // Source MAC address
    unsigned short ether_type;                     // Type of Ethernet packet
};

struct ip_hdr
{
    unsigned char ip_version_and_header_length; // Version and header length
    unsigned char ip_tos;                       // Type of service
    unsigned short ip_len;                      // Total length
    unsigned short ip_id;                       // Identification number
    unsigned short ip_frag_offset;              // Fragment offset and flags
    unsigned char ip_ttl;                       // Time to live
    unsigned char ip_type;                      // Protocol type
    unsigned short ip_checksum;                 // Checksum
    unsigned int ip_src_addr;                   // Source IP address
    unsigned int ip_dest_addr;                  // Destination IP address
};

struct tcp_hdr
{
    unsigned short tcp_src_port;  // Source TCP port
    unsigned short tcp_dest_port; // Destination TCP port
    unsigned int tcp_seq;         // TCP sequence number
    unsigned int tcp_ack;         // TCP acknowledgment number
    unsigned char reserved : 4;   // 4 bits from the 6 bits of reserved space
    unsigned char tcp_offset : 4; // TCP data offset for little-endian host
    unsigned char tcp_flags;      // TCP flags (and 2 bits from reserved space)
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PUSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20
    unsigned short tcp_window;   // TCP window size
    unsigned short tcp_checksum; // TCP checksum
    unsigned short tcp_urgent;   // TCP urgent pointer
};