#include <pcap.h>
#include "../hacking.h"
#include "../hacking-network.h"

void pcap_fatal(const char *, const char *);
void decode_ethernet(const u_char *);
void decode_ip(const u_char *);
u_int decode_tcp(const u_char *);
void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
char *iptostring(unsigned int valor);

int main()
{
    struct pcap_pkthdr cap_header;
    const u_char *packet, *pkt_data;

    //The errbuf variable is the aforementioned error buffer, its size coming from a define in pcap.h set to 256
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_if_t *interfaces, *device;

    pcap_t *pcap_handle;

    //Retieves all the interfaces available
    if (pcap_findalldevs(&interfaces, errbuf) == -1)
        pcap_fatal("pcap_lookupdev", errbuf);

    //Print the available devices
    printf("\nAvailable Devices are :\n");
    for (device = interfaces; device != NULL; device = device->next)
    {
        printf("%s - %s\n", device->name, device->description);
    }
    printf("Sniffing on device %s\n", interfaces[0].name);

    /* pcap_open_live() function opens a packet-capturing device, returning a handle to it. The arguments for this function are the device to sniff, 
    the maximum packet size, a promiscuous flag, a timeout value, and a pointer to the error buffer*/
    pcap_handle = pcap_open_live(interfaces[0].name, 4096, 1, 0, errbuf);
    if (pcap_handle == NULL)
        pcap_fatal("pcap_open_live", errbuf);

    /*The pcap_loop() retrieves packages for the device. 
    * We have to specify how many packages to capture, three in this case. If we inform -1 it will continue capturing packages indefinitelly
    * We also specify a call back function that will be in charge of processing the package. We may also specify optionally an argument to the function*/
    pcap_loop(pcap_handle, 3, caught_packet, NULL);
    pcap_close(pcap_handle);
}

//Callback to process the package. Takes the argument that was - optionally - passed in the pcap_loop function, the pointer to the ethernet package header and body
void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet)
{
    int tcp_header_length, total_header_size, pkt_data_len;
    u_char *pkt_data;
    int size = cap_header->len;

    //Tamaño de la cabecera
    printf("==== Got a %d byte packet ====\n", size);

    //Ethernet package
    decode_ethernet(packet);
    //IP package
    decode_ip(packet + ETHER_HDR_LEN);
    //TCP package
    tcp_header_length = decode_tcp(packet + ETHER_HDR_LEN + sizeof(struct ip_hdr));
    total_header_size = ETHER_HDR_LEN + sizeof(struct ip_hdr) + tcp_header_length;
    //Data
    pkt_data = (u_char *)packet + total_header_size; // pkt_data points to the data portion.
    pkt_data_len = cap_header->len - total_header_size;
    if (pkt_data_len > 0)
    {
        printf("\t\t\t%u bytes of packet data\n", pkt_data_len);
        dump(pkt_data, pkt_data_len);
    }
    else
        printf("\t\t\tNo Packet Data\n");
}

void pcap_fatal(const char *failed_in, const char *errbuf)
{
    printf("Fatal Error in %s: %s\n", failed_in, errbuf);
    exit(1);
}

void decode_ethernet(const u_char *header_start)
{
    int i;
    const struct ether_hdr *ethernet_header;
    ethernet_header = (const struct ether_hdr *)header_start;
    printf("[[ Layer 2 :: Ethernet Header ]]\n");
    //Source MAC
    printf("[ Source: %02x", ethernet_header->ether_src_addr[0]);
    for (i = 1; i < ETHER_ADDR_LEN; i++)
        printf(":%02x", ethernet_header->ether_src_addr[i]);
    //Destination MAC
    printf("\tDest: %02x", ethernet_header->ether_dest_addr[0]);
    for (i = 1; i < ETHER_ADDR_LEN; i++)
        printf(":%02x", ethernet_header->ether_dest_addr[i]);
    //Type of message - IP, ARP req, ARP reply
    printf("\tType: %hu ]\n", ethernet_header->ether_type);
}

void decode_ip(const u_char *header_start)
{
    const struct ip_hdr *ip_header;
    ip_header = (const struct ip_hdr *)header_start;
    printf("\t(( Layer 3 ::: IP Header ))\n");
    //Source IP
    printf("\t( Source: %s\t", iptostring(ip_header->ip_src_addr));
    //Destination IP
    printf("Dest: %s )\n", iptostring(ip_header->ip_dest_addr));

    //Protocolo y tamaño del header
    printf("\t( Type: %u\t", (u_int)ip_header->ip_type);
    printf("ID: %hu\tLength: %hu )\n", ntohs(ip_header->ip_id), ntohs(ip_header->ip_len));
}

u_int decode_tcp(const u_char *header_start)
{
    u_int header_size;
    const struct tcp_hdr *tcp_header;
    tcp_header = (const struct tcp_hdr *)header_start;
    header_size = 4 * tcp_header->tcp_offset;
    printf("\t\t{{ Layer 4 :::: TCP Header }}\n");
    //Puerto origen
    printf("\t\t{ Src Port: %hu\t", ntohs(tcp_header->tcp_src_port));
    //Puerto destino
    printf("Dest Port: %hu }\n", ntohs(tcp_header->tcp_dest_port));
    //Secuencia
    printf("\t\t{ Seq #: %u\t", ntohl(tcp_header->tcp_seq));
    //Secuencia del ACK
    printf("Ack #: %u }\n", ntohl(tcp_header->tcp_ack));
    //Tamaño de la cabecera
    printf("\t\t{ Header Size: %u\tFlags: ", header_size);
    //Flags TCP
    if (tcp_header->tcp_flags & TCP_FIN)
        printf("FIN ");
    if (tcp_header->tcp_flags & TCP_SYN)
        printf("SYN ");
    if (tcp_header->tcp_flags & TCP_RST)
        printf("RST ");
    if (tcp_header->tcp_flags & TCP_PUSH)
        printf("PUSH ");
    if (tcp_header->tcp_flags & TCP_ACK)
        printf("ACK ");
    if (tcp_header->tcp_flags & TCP_URG)
        printf("URG ");
    printf(" }\n");
    return header_size;
}

char *iptostring(unsigned int valor)
{
    char *respuesta = malloc(15);
    char *val;
    val = (char *)&valor;
    sprintf(respuesta, "%u.%u.%u.%u", *(val + 3), *(val + 2), *(val + 1), *val);

    return respuesta;
}