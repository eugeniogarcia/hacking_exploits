#include <stdio.h>
#include <stdlib.h>
#include <libnet.h>
#include <stdint.h>
#include <unistd.h>

/*
En reaping clear con cada paquete se crean las cabeceras, la tcp/udp/icmp
En reaping tags usamos la tecnica de "tags" para reutilizar las cabeceras que hemos creado
*/

int main()
{

    libnet_t *l; /* libnet context */
    char errbuf[LIBNET_ERRBUF_SIZE], ip_addr_str[16];
    u_int32_t ip_addr;
    libnet_ptag_t icmp_tag, ip_tag;
    u_int16_t id, seq;
    int i;

    l = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (l == NULL)
    {
        fprintf(stderr, "libnet_init() failed: %s\n", errbuf);
        exit(EXIT_FAILURE);
    }

    icmp_tag = ip_tag = LIBNET_PTAG_INITIALIZER;

    /* Generating a random id */

    libnet_seed_prand(l);
    id = (u_int16_t)libnet_get_prand(LIBNET_PR16);

    /* Getting destination IP address */

    printf("Destination IP address: ");
    scanf("%15s", ip_addr_str);

    ip_addr = libnet_name2addr4(l, ip_addr_str, LIBNET_DONT_RESOLVE);

    if (ip_addr == -1)
    {
        fprintf(stderr, "Error converting IP address.\n");
        libnet_destroy(l);
        exit(EXIT_FAILURE);
    }

    /* Building ICMP header */

    seq = 1;
    /*
    seq (sequence number)
    id (identification number)
    payload (the extra data we’re sending)
    payload_s (the payload’s size). 
    l is the libnet context we initialized with libnet_init(). 
    
    Don’t worry about the libnet_ptag_t type and ptag, we will talk about them later when we are sending multiple packets.
    */
    icmp_tag = libnet_build_icmpv4_echo(ICMP_ECHO, //type
                                        0,         //code
                                        0,         //sum
                                        id,        //id
                                        seq,       //seq
                                        NULL,      //payload
                                        0,         //payload_s
                                        l,
                                        0); //ptag
    if (icmp_tag == -1)
    {
        fprintf(stderr, "Error building ICMP header: %s\n", libnet_geterror(l));
        libnet_destroy(l);
        exit(EXIT_FAILURE);
    }

    /* Building IP header */
    /*
    libnet_ptag_t libnet_build_ipv4 (u_int16_t len,
    u_int8_t tos,
    u_int16_t id,
    u_int16_t frag,
    u_int8_t ttl, 
    u_int8_t prot,
    u_int16_t sum,
    u_int32_t src, 
    u_int32_t dst,
    u_int8_t * payload,
    u_int32_t payload_s,
    libnet_t * l,
    libnet_ptag_t ptag)

    len is total packet length (from the network layer POV, i.e. not including the link layer header);
    tos is type of service (useless, set to 0);
    id is the sequential id number (leave as 0 for the kernel to fill it in for you);
    frag is fragmentation flags and offset (0 for no fragmentation (if do want it, checkout advanced mode below));
    prot is the next header’s protocol (useful macros are IPPROTO_ICMP, IPPROTO_TCP, IPPROTO_UDP);
    ttl is time to live, the number of hops before a router discards your packet considering it entered a routing loop (usually set to 64 or 255, or incremented from 1 for tracerouting, for example);
    sum is the checksum (leave as 0 for the kernel to fill it in);
    src and dst are the source and destination addresses;
    payload and payload_s are a pointer to and length of the payload (NULL and 0 if there’s none);
    l and ptag are libnet’s context 
    and the tag used to modify this header (see next section).
    */
    //Con tag lo que hacemos es disponer de un mecanismo que nos permite reutilizar la cabecera que ya hemos construido
    ip_tag = libnet_autobuild_ipv4(LIBNET_IPV4_H + LIBNET_ICMPV4_ECHO_H, //len
                                   IPPROTO_ICMP,                         //prot
                                   ip_addr,                              //dst
                                   l);

    if (ip_tag == -1)
    {
        fprintf(stderr, "Error building IP header: %s\n", libnet_geterror(l));
        libnet_destroy(l);
        exit(EXIT_FAILURE);
    }

    /* Writing 4 packets */

    for (i = 0; i < 4; i++)
    {

        /* Updating the ICMP header */
        //Con tag lo que hacemos es disponer de un mecanismo que nos permite reutilizar la cabecera que ya hemos construido
        icmp_tag = libnet_build_icmpv4_echo(ICMP_ECHO, 0, 0, id, (seq + i), NULL, 0, l, icmp_tag);

        if (icmp_tag == -1)
        {
            fprintf(stderr, "Error building ICMP header: %s\n", libnet_geterror(l));
            libnet_destroy(l);
            exit(EXIT_FAILURE);
        }

        if (libnet_write(l) == -1)
            fprintf(stderr, "Error writing packet: %s\n", libnet_geterror(l));

        /* Waiting 1 second between each packet */
        sleep(1);
    }

    libnet_destroy(l);
    return 0;
}