# Compila y Depura

## Compila

Compila:

```ps
gcc <fuente>
```

Especificando el nombre del ejecutable:

```ps
gcc -o <salida> <fuente>
```

Incluyendo simbolos para que el depurador los interprete:

```ps
gcc -g -o <salida> <fuente>
```

Compilamos deshabilitando las validaciones de stack overflow - los canaries que gcc inserta para verificar que no haya buffer overflows:

```ps
gcc -g -o <salida> -zexecstack -fno-stack-protector <fuente>
```

Para compilar en 32 bytes en una máquina de 64 bytes:

```ps
gcc -m32 -g -zexecstack -fno-stack-protector -o <salida> <fuente>
```

Si al compilar tenemos un error relativo a alguna librería que falta, es preciso instalar lo siguiente:

```ps
sudo apt-get install gcc-multilib
```

## Decompila

Decompila:

```ps
objdump -M intel -D a.out | grep -A20 main
```

```ps
objdump -D a.out | grep -A20 main
```

## Depurador

Lanza el depurador:

```ps
gdb -q <ejecutable>
```

Utiliza el formato intel para desensamblar. Podemos ejecutarlo en la línea de comandos del depurador:

```ps
set disassembly intel
```

o si preferimos que sea la opción por defecto, configurarlo así en el archivo de configuración:

```ps
echo "set disassembly intel" > ~/.gdbinit
```

Listar el fuente:

```ps
list
```

```ps
(gdb) list
1       #include <stdio.h>
2       int main()
3       {
4               int i;
5
6               for(i=0; i < 10; i++) // Loop 10 times.
7               {
8                       puts("Hello, world!\n"); // put the string to the output.
9               }
10
```

Mostrar el código en ensamblador:

```ps
disassemble <funcion>
```

```ps
disassemble main
```

```ps
Dump of assembler code for function main:
   0x000000000000063a <+0>:     push   rbp
   0x000000000000063b <+1>:     mov    rbp,rsp
   0x000000000000063e <+4>:     sub    rsp,0x10
   0x0000000000000642 <+8>:     mov    DWORD PTR [rbp-0x4],0x0
   0x0000000000000649 <+15>:    jmp    0x65b <main+33>
   0x000000000000064b <+17>:    lea    rdi,[rip+0xa2]        # 0x6f4
   0x0000000000000652 <+24>:    call   0x510 <puts@plt>
   0x0000000000000657 <+29>:    add    DWORD PTR [rbp-0x4],0x1
   0x000000000000065b <+33>:    cmp    DWORD PTR [rbp-0x4],0x9
   0x000000000000065f <+37>:    jle    0x64b <main+17>
   0x0000000000000661 <+39>:    mov    eax,0x0
   0x0000000000000666 <+44>:    leave
   0x0000000000000667 <+45>:    ret
```

Poner un breakpoint en la función _main_:

```ps
break main
```

También podemos poner el break point en una línea concreta:

```ps
break 11
```

Ejecutar el programa en el depurador:

```ps
run
```

Mostrar la información de los registros:

```ps
info registers
```

```ps
rax            0x800063a        134219322
rbx            0x0      0
rcx            0x8000670        134219376
rdx            0x7ffffffedab8   140737488280248
rsi            0x7ffffffedaa8   140737488280232
rdi            0x1      1
rbp            0x7ffffffed9c0   0x7ffffffed9c0
rsp            0x7ffffffed9b0   0x7ffffffed9b0
r8             0x7fffff3ecd80   140737475693952
r9             0x7fffff3ecd80   140737475693952
r10            0x2      2
r11            0x7      7
r12            0x8000530        134219056
r13            0x7ffffffedaa0   140737488280224
r14            0x0      0
r15            0x0      0
rip            0x8000642        0x8000642 <main+8>
eflags         0x202    [ IF ]
cs             0x33     51
ss             0x2b     43
ds             0x0      0
es             0x0      0
fs             0x0      0
gs             0x0      0
```

- Los que termina en `p` son punteros, es decir, contienen direcciones de memoria (rip, rbp, rsp)
- en *eflags* tenemos el valor de varios flags
- Los que terminan en `x` hacen referencia a contadores (rax, acumulador, rcx, contadores, rdx, datos)

Podemos ver el contenido de un registro:

```ps
info register rip
```

```ps
rip            0x8000642        0x8000642 <main+8>
```

Una abreviatura que hace lo mismo:

```ps
i r rip
```

```ps
rip            0x8000642        0x8000642 <main+8>
```

Podemos ver el contenido del frame del stack:

```ps
info frame
```

Podemos inspeccionar una posición de memoria:

```ps
x/h 0x8000642
```

- x/x hexadecimal
- x/o octal
- x/u decimal (unsigned)
- x/t binario

```ps
0x8000642 <main+8>:     17863
```

Contenido en hexadecimal de la posición de memoria a la que apunta el registro `rip`:

```ps
x/x $rip
```

Podemos mostrar más posiciones de memoria, por ejemplo, en este caso 4:

```ps
x/4x $rip
```

Podemos indicar también como considerar los datos:

- b. Como byte
- h. Como media palabra - dos bytes
- w. Como word - cuatro bytes
- g. Como giant - ocho bytes 

```ps
x/8xb $rip
```

La información en procesadores _x86_ se guarda en _little indian_, es decir, primero se guardan las posiciones menos significativas.

Podemos también inspeccionar la instruccion en la posición:

```ps
x/i $rip
```

O, por ejemplo varias instrucciones. En este caso tres:

```ps
x/3i $rip
```

Hay una par de opciones más que podemos usar con _explore, x_, la opción de visualizar los datos en ASCII. podemos hacer el lookup byte a byte, o tomarlo como un string. Esto nos mostraría cuatro bytes, y su representación ascii:

Por ejemplo, los cinco bytes en la dirección 0x80006f4 serían:

```ps
x/5cb 0x80006f4
```

```ps
0x80006f4:      72 'H'  101 'e' 108 'l' 108 'l' 111 'o'
```

Esto nos mostraría el string en la dirección 0x80006f4:

```ps
x/s 0x80006f4
```

```ps
0x80006f4:      "Hello, world!\n"
```

Podemos tambien hacer referencia a variables declaradas en el fuente por su nombre. También podemos usar los operandos `&` y `*`:

```ps
x/s &variable
```

Podemos ejecutar el siguiente paso:

```ps
nexti
```

Podemos retormar la ejecución:

```ps
cont
```

Podemos consultar la pila:

```ps
bt
```

Mostrar los valores por defecto en hexadecimal:

```ps
set output-radix 16
```

o en decimal:

```ps
set output-radix 10
```

Salir del depurador:

```ps
quit
```

## Linux

Crear usuarios:

```ps
useradd <usuario>
```

```ps
su <usuario>

whoami
```

```ps
egsmartin@Eugenio:~/Downloads/hacking$ which chsh
/usr/bin/chsh

egsmartin@Eugenio:~/Downloads/hacking$ ls /usr/bin/chsh
/usr/bin/chsh
```

```ps
chmod u+s ./user
```

Lista todos los dispositivos disponibles:

```ps
lsblk
```

Monta en la unidad `/mnt` un disco:

```ps
mnt /dev/sda4 /mnt
```
